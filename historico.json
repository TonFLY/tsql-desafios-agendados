[
  {
    "role": "user",
    "content": "\nVocê é um especialista sênior em T-SQL com foco em performance e arquitetura de banco de dados.\n\nSeu papel é criar **um desafio prático e avançado** que ajude o aluno a desenvolver as seguintes habilidades:\n\n1. Criação de *views* altamente performáticas, evitando funções escalares, usando `WITH (NOLOCK)` quando apropriado, otimizando `JOINs`, usando `CTEs`, e filtrando corretamente com `WHERE`.\n2. Escrita de *stored procedures* bem estruturadas, com:\n   - Parâmetros de entrada e saída;\n   - Boas práticas de nomenclatura;\n   - Tratamento de erros com `TRY...CATCH`;\n   - Comentários e modularização.\n3. Leitura e interpretação de plano de execução (dê dicas e armadilhas comuns).\n4. Uso de `INNER JOIN`, `LEFT JOIN`, `EXISTS`, `NOT EXISTS`, e boas práticas em filtros e subconsultas.\n\n**Regras para o desafio:**\n- Baseie-se no desafio anterior, se houver.\n- Crie tabelas e dados de exemplo.\n- Explique o desafio de forma didática.\n- Dê dicas, possíveis erros e links úteis de estudo.\n- **Não entregue a solução!**\n\nDesafio anterior: Nenhum.\n"
  },
  {
    "role": "bot",
    "content": "Ótimo! Vamos criar um **desafio prático e avançado** para te ajudar a desenvolver as competências essenciais de um(a) analista sênior de banco de dados SQL Server. Este desafio simula um cenário real de uma empresa de e-commerce.\n\n---\n\n## **Cenário do Desafio**\n\nVocê faz parte do time responsável pelo banco de dados de uma plataforma de e-commerce. O time de BI precisa de uma visão detalhada dos pedidos, clientes e produtos, e também de stored procedures para relatórios de vendas e auditoria de inconsistências.\n\n### **1. Estrutura de Dados de Exemplo**\n\nCrie as seguintes tabelas (com alguns campos principais):\n\n```sql\nCREATE TABLE Clientes (\n    ClienteId INT PRIMARY KEY,\n    Nome NVARCHAR(100),\n    Email NVARCHAR(100),\n    DataCadastro DATE\n);\n\nCREATE TABLE Produtos (\n    ProdutoId INT PRIMARY KEY,\n    Nome NVARCHAR(100),\n    Preco DECIMAL(10,2),\n    Ativo BIT\n);\n\nCREATE TABLE Pedidos (\n    PedidoId INT PRIMARY KEY,\n    ClienteId INT FOREIGN KEY REFERENCES Clientes(ClienteId),\n    DataPedido DATETIME,\n    Status NVARCHAR(20)\n);\n\nCREATE TABLE ItensPedido (\n    ItemPedidoId INT PRIMARY KEY,\n    PedidoId INT FOREIGN KEY REFERENCES Pedidos(PedidoId),\n    ProdutoId INT FOREIGN KEY REFERENCES Produtos(ProdutoId),\n    Quantidade INT,\n    PrecoUnitario DECIMAL(10,2)\n);\n```\n\n**Popule com pelo menos 5 registros em cada tabela para seus testes.**\n\n---\n\n## **Desafio Prático**\n\n### **Parte 1: Criação de uma View Performática**\n\nCrie uma `VIEW` chamada `vw_PedidosDetalhados` que traga:\n\n- Dados do pedido (ID, data, status);\n- Nome e email do cliente;\n- Nome do produto, quantidade, valor total do item (`Quantidade * PrecoUnitario`);\n- Valor total do pedido (soma dos itens);\n- Apenas pedidos dos últimos 90 dias com status ‘Finalizado’;\n- **Evite funções escalares** em colunas;\n- Use `WITH (NOLOCK)` nos joins – **mas só onde faz sentido**;\n- Use `CTE` se necessário para clareza e performance;\n- Atenção ao uso de `INNER JOIN` vs `LEFT JOIN` (pense em pedidos sem itens, produtos inativos etc.);\n- Filtre apenas produtos ativos.\n\n**Desafio extra:** Mostre na view se o cliente já tem mais de 3 pedidos (campo: ClienteFrequente BIT).\n\n---\n\n### **Parte 2: Stored Procedure Estruturada**\n\nCrie uma procedure chamada `sp_RelatorioVendasProduto` que deve:\n\n- Receber como parâmetro o `@ProdutoId` e um intervalo de datas (`@DataInicio`, `@DataFim`);\n- Retornar: total de vendas do produto, quantidade total vendida, número de clientes distintos que compraram;\n- Ter um parâmetro de saída `@ErroMensagem NVARCHAR(200)` para retornar mensagens de erro amigáveis;\n- Usar **TRY...CATCH** para tratamento de erros;\n- Utilizar comentários claros (bloco e linhas);\n- Seguir boas práticas de nomenclatura (prefixos, caixa, clareza);\n- Modularize a lógica, se possível (ex: subqueries nomeadas, CTEs, etc).\n\n---\n\n### **Parte 3: Interpretação de Plano de Execução**\n\nApós criar a view e a procedure:\n\n- **Analise o plano de execução** ao rodar a view e a procedure.\n- Identifique possíveis gargalos: uso de Table/Index Scan vs Index Seek, operadores de Hash, Nested Loops, etc.\n- Liste **2 armadilhas comuns** que afetam performance (por exemplo: funções escalares, joins mal feitos, falta de índices).\n- **Dica:** Use o comando `SET STATISTICS IO ON` e o GUI do SSMS para analisar.\n\n---\n\n### **Parte 4: Pratique Joins e Subconsultas**\n\n- Reescreva uma consulta para mostrar todos os clientes que **nunca fizeram pedidos** usando `NOT EXISTS`.\n- Outra consulta para listar produtos **que nunca foram vendidos** (usando `LEFT JOIN`).\n- Pratique filtros eficientes: use `EXISTS` para encontrar clientes que tenham mais de 1 pedido nos últimos 30 dias.\n\n---\n\n## **Dicas e Armadilhas Comuns**\n\n- **Evite funções escalares** no SELECT; prefira CTEs ou subconsultas.\n- **Joins mal planejados** podem causar explosão de linhas ou Table Scans.\n- **WITH (NOLOCK)**: cuidado, use apenas em relatórios não críticos (pode haver leituras \"sujas\").\n- **Índices**: Verifique se suas tabelas têm índices adequados nas colunas de junção e filtro.\n- **Plano de execução**: fique atento a *warnings* e operações de alto custo.\n\n---\n\n## **Links para Estudo**\n\n- [Documentação oficial T-SQL Views](https://learn.microsoft.com/pt-br/sql/t-sql/statements/create-view-transact-sql)\n- [Guia de Stored Procedures](https://learn.microsoft.com/pt-br/sql/t-sql/statements/create-procedure-transact-sql)\n- [Como ler o plano de execução](https://learn.microsoft.com/pt-br/sql/relational-databases/performance/display-an-actual-execution-plan)\n- [Diferença entre EXISTS, IN e JOIN](https://www.sqlshack.com/sql-server-exists-vs-in-vs-join-vs-subquery/)\n\n---\n\n## **Possíveis Erros**\n\n- Filtros no lugar errado (ex: depois do JOIN, causando retornos errados).\n- Falta de tratamento de erro na procedure.\n- Uso incorreto de `NOLOCK` (pode trazer dados inconsistentes).\n- Junção de tabelas desnecessárias.\n- Colunas calculadas no SELECT ao invés de CTE/subquery.\n\n---\n\n## **Desafio de Carreira**\n\n- Pense como um DBA: como deixaria esse ambiente preparado para crescimento?\n- Como versionaria esses scripts e objetos?\n- Que convenções de nomenclatura adotaria?\n- Que índices criaria para otimizar as queries principais?\n\n---\n\n**Mãos à obra! Se tiver dúvidas ou quiser compartilhar sua solução para revisão, envie seu código!**"
  },
  {
    "role": "user",
    "content": "\nVocê é um tutor experiente em T-SQL Avançado.\n\nAgora, entregue a solução detalhada do seguinte desafio, explicando passo a passo, com código exemplo e raciocínio claro.\n\nDesafio: Ótimo! Vamos criar um **desafio prático e avançado** para te ajudar a desenvolver as competências essenciais de um(a) analista sênior de banco de dados SQL Server. Este desafio simula um cenário real de uma empresa de e-commerce.\n\n---\n\n## **Cenário do Desafio**\n\nVocê faz parte do time responsável pelo banco de dados de uma plataforma de e-commerce. O time de BI precisa de uma visão detalhada dos pedidos, clientes e produtos, e também de stored procedures para relatórios de vendas e auditoria de inconsistências.\n\n### **1. Estrutura de Dados de Exemplo**\n\nCrie as seguintes tabelas (com alguns campos principais):\n\n```sql\nCREATE TABLE Clientes (\n    ClienteId INT PRIMARY KEY,\n    Nome NVARCHAR(100),\n    Email NVARCHAR(100),\n    DataCadastro DATE\n);\n\nCREATE TABLE Produtos (\n    ProdutoId INT PRIMARY KEY,\n    Nome NVARCHAR(100),\n    Preco DECIMAL(10,2),\n    Ativo BIT\n);\n\nCREATE TABLE Pedidos (\n    PedidoId INT PRIMARY KEY,\n    ClienteId INT FOREIGN KEY REFERENCES Clientes(ClienteId),\n    DataPedido DATETIME,\n    Status NVARCHAR(20)\n);\n\nCREATE TABLE ItensPedido (\n    ItemPedidoId INT PRIMARY KEY,\n    PedidoId INT FOREIGN KEY REFERENCES Pedidos(PedidoId),\n    ProdutoId INT FOREIGN KEY REFERENCES Produtos(ProdutoId),\n    Quantidade INT,\n    PrecoUnitario DECIMAL(10,2)\n);\n```\n\n**Popule com pelo menos 5 registros em cada tabela para seus testes.**\n\n---\n\n## **Desafio Prático**\n\n### **Parte 1: Criação de uma View Performática**\n\nCrie uma `VIEW` chamada `vw_PedidosDetalhados` que traga:\n\n- Dados do pedido (ID, data, status);\n- Nome e email do cliente;\n- Nome do produto, quantidade, valor total do item (`Quantidade * PrecoUnitario`);\n- Valor total do pedido (soma dos itens);\n- Apenas pedidos dos últimos 90 dias com status ‘Finalizado’;\n- **Evite funções escalares** em colunas;\n- Use `WITH (NOLOCK)` nos joins – **mas só onde faz sentido**;\n- Use `CTE` se necessário para clareza e performance;\n- Atenção ao uso de `INNER JOIN` vs `LEFT JOIN` (pense em pedidos sem itens, produtos inativos etc.);\n- Filtre apenas produtos ativos.\n\n**Desafio extra:** Mostre na view se o cliente já tem mais de 3 pedidos (campo: ClienteFrequente BIT).\n\n---\n\n### **Parte 2: Stored Procedure Estruturada**\n\nCrie uma procedure chamada `sp_RelatorioVendasProduto` que deve:\n\n- Receber como parâmetro o `@ProdutoId` e um intervalo de datas (`@DataInicio`, `@DataFim`);\n- Retornar: total de vendas do produto, quantidade total vendida, número de clientes distintos que compraram;\n- Ter um parâmetro de saída `@ErroMensagem NVARCHAR(200)` para retornar mensagens de erro amigáveis;\n- Usar **TRY...CATCH** para tratamento de erros;\n- Utilizar comentários claros (bloco e linhas);\n- Seguir boas práticas de nomenclatura (prefixos, caixa, clareza);\n- Modularize a lógica, se possível (ex: subqueries nomeadas, CTEs, etc).\n\n---\n\n### **Parte 3: Interpretação de Plano de Execução**\n\nApós criar a view e a procedure:\n\n- **Analise o plano de execução** ao rodar a view e a procedure.\n- Identifique possíveis gargalos: uso de Table/Index Scan vs Index Seek, operadores de Hash, Nested Loops, etc.\n- Liste **2 armadilhas comuns** que afetam performance (por exemplo: funções escalares, joins mal feitos, falta de índices).\n- **Dica:** Use o comando `SET STATISTICS IO ON` e o GUI do SSMS para analisar.\n\n---\n\n### **Parte 4: Pratique Joins e Subconsultas**\n\n- Reescreva uma consulta para mostrar todos os clientes que **nunca fizeram pedidos** usando `NOT EXISTS`.\n- Outra consulta para listar produtos **que nunca foram vendidos** (usando `LEFT JOIN`).\n- Pratique filtros eficientes: use `EXISTS` para encontrar clientes que tenham mais de 1 pedido nos últimos 30 dias.\n\n---\n\n## **Dicas e Armadilhas Comuns**\n\n- **Evite funções escalares** no SELECT; prefira CTEs ou subconsultas.\n- **Joins mal planejados** podem causar explosão de linhas ou Table Scans.\n- **WITH (NOLOCK)**: cuidado, use apenas em relatórios não críticos (pode haver leituras \"sujas\").\n- **Índices**: Verifique se suas tabelas têm índices adequados nas colunas de junção e filtro.\n- **Plano de execução**: fique atento a *warnings* e operações de alto custo.\n\n---\n\n## **Links para Estudo**\n\n- [Documentação oficial T-SQL Views](https://learn.microsoft.com/pt-br/sql/t-sql/statements/create-view-transact-sql)\n- [Guia de Stored Procedures](https://learn.microsoft.com/pt-br/sql/t-sql/statements/create-procedure-transact-sql)\n- [Como ler o plano de execução](https://learn.microsoft.com/pt-br/sql/relational-databases/performance/display-an-actual-execution-plan)\n- [Diferença entre EXISTS, IN e JOIN](https://www.sqlshack.com/sql-server-exists-vs-in-vs-join-vs-subquery/)\n\n---\n\n## **Possíveis Erros**\n\n- Filtros no lugar errado (ex: depois do JOIN, causando retornos errados).\n- Falta de tratamento de erro na procedure.\n- Uso incorreto de `NOLOCK` (pode trazer dados inconsistentes).\n- Junção de tabelas desnecessárias.\n- Colunas calculadas no SELECT ao invés de CTE/subquery.\n\n---\n\n## **Desafio de Carreira**\n\n- Pense como um DBA: como deixaria esse ambiente preparado para crescimento?\n- Como versionaria esses scripts e objetos?\n- Que convenções de nomenclatura adotaria?\n- Que índices criaria para otimizar as queries principais?\n\n---\n\n**Mãos à obra! Se tiver dúvidas ou quiser compartilhar sua solução para revisão, envie seu código!**\n"
  },
  {
    "role": "bot",
    "content": "Excelente, vamos resolver o desafio **passo a passo**, trazendo o raciocínio de performance, boas práticas e explicações didáticas em cada parte.  \nVou assumir que as tabelas já foram criadas e populadas conforme o enunciado.\n\n---\n\n## **Parte 1: View Performática – `vw_PedidosDetalhados`**\n\n### **Raciocínio Técnico**\n\n1. **Selecionar apenas pedidos dos últimos 90 dias e status ‘Finalizado’**: Filtro no início para reduzir volume de dados.\n2. **Evitar funções escalares**: Utilize CTEs e subqueries para cálculos.\n3. **Usar WHERE para filtrar produtos ativos**.\n4. **Join com NOLOCK**: Só em tabelas de leitura pesada, nunca em transações críticas.\n5. **Valor Total do Pedido**: Use um CTE que agregue por pedido e una por JOIN.\n6. **ClienteFrequente**: Subquery ou CTE para marcar clientes com mais de 3 pedidos.\n\n### **Código Explicado**\n\n```sql\n-- Criação da view vw_PedidosDetalhados\nCREATE OR ALTER VIEW dbo.vw_PedidosDetalhados\nAS\nWITH PedidosRecentes AS (\n    SELECT\n        p.PedidoId,\n        p.ClienteId,\n        p.DataPedido,\n        p.Status\n    FROM\n        dbo.Pedidos p WITH (NOLOCK)\n    WHERE\n        p.Status = 'Finalizado'\n        AND p.DataPedido >= DATEADD(DAY, -90, GETDATE())\n),\nTotalPedido AS (\n    SELECT\n        ip.PedidoId,\n        SUM(ip.Quantidade * ip.PrecoUnitario) AS ValorTotalPedido\n    FROM\n        dbo.ItensPedido ip WITH (NOLOCK)\n        INNER JOIN dbo.Produtos pr WITH (NOLOCK) ON ip.ProdutoId = pr.ProdutoId\n    WHERE\n        pr.Ativo = 1\n    GROUP BY\n        ip.PedidoId\n),\nClienteFrequente AS (\n    SELECT\n        c.ClienteId,\n        CASE WHEN COUNT(p.PedidoId) > 3 THEN CAST(1 AS BIT) ELSE CAST(0 AS BIT) END AS ClienteFrequente\n    FROM\n        dbo.Clientes c WITH (NOLOCK)\n        LEFT JOIN dbo.Pedidos p WITH (NOLOCK) ON c.ClienteId = p.ClienteId\n    GROUP BY\n        c.ClienteId\n)\nSELECT\n    pr.PedidoId,\n    pr.DataPedido,\n    pr.Status,\n    c.Nome AS NomeCliente,\n    c.Email AS EmailCliente,\n    prod.Nome AS NomeProduto,\n    ip.Quantidade,\n    ip.PrecoUnitario,\n    ip.Quantidade * ip.PrecoUnitario AS ValorTotalItem,\n    tp.ValorTotalPedido,\n    cf.ClienteFrequente\nFROM\n    PedidosRecentes pr\n    INNER JOIN dbo.Clientes c WITH (NOLOCK) ON pr.ClienteId = c.ClienteId\n    INNER JOIN dbo.ItensPedido ip WITH (NOLOCK) ON pr.PedidoId = ip.PedidoId\n    INNER JOIN dbo.Produtos prod WITH (NOLOCK) ON ip.ProdutoId = prod.ProdutoId AND prod.Ativo = 1\n    INNER JOIN TotalPedido tp ON pr.PedidoId = tp.PedidoId\n    INNER JOIN ClienteFrequente cf ON pr.ClienteId = cf.ClienteId\n```\n\n### **Boas Práticas Aplicadas**\n- Filtros de datas e status logo no início.\n- Cálculo de totais em CTEs, evitando cálculos linha a linha.\n- CTE para marcação de clientes frequentes, evitando função escalar.\n- Uso de `WITH (NOLOCK)` apenas em tabelas de leitura, nunca em transações críticas.\n- Apenas produtos ativos no resultado final.\n\n---\n\n## **Parte 2: Stored Procedure Estruturada – `sp_RelatorioVendasProduto`**\n\n### **Raciocínio Técnico**\n\n- **Parâmetros de entrada:** Produto, intervalo de datas.\n- **Saída:** Total vendido, quantidade, clientes distintos.\n- **Tratamento de erros com TRY…CATCH**.\n- **Parâmetro de saída para mensagem de erro**.\n- **CTEs/Subqueries para modularizar e facilitar manutenção**.\n- **Comentários para clareza**.\n\n### **Código Explicado**\n\n```sql\nCREATE OR ALTER PROCEDURE dbo.sp_RelatorioVendasProduto\n    @ProdutoId INT,\n    @DataInicio DATE,\n    @DataFim DATE,\n    @ErroMensagem NVARCHAR(200) OUTPUT\nAS\nBEGIN\n    SET NOCOUNT ON;\n\n    BEGIN TRY\n        -- Inicializa mensagem de erro\n        SET @ErroMensagem = NULL;\n\n        -- CTE para consolidar vendas do produto no período\n        WITH VendasProdutoPeriodo AS (\n            SELECT\n                ip.PedidoId,\n                p.ClienteId,\n                ip.Quantidade,\n                ip.PrecoUnitario\n            FROM\n                dbo.ItensPedido ip WITH (NOLOCK)\n                INNER JOIN dbo.Pedidos p WITH (NOLOCK) ON ip.PedidoId = p.PedidoId\n            WHERE\n                ip.ProdutoId = @ProdutoId\n                AND p.DataPedido >= @DataInicio\n                AND p.DataPedido <= @DataFim\n                AND p.Status = 'Finalizado'\n        )\n        SELECT\n            SUM(Quantidade * PrecoUnitario) AS TotalVendas,\n            SUM(Quantidade) AS QuantidadeTotalVendida,\n            COUNT(DISTINCT ClienteId) AS NumeroClientesDistintos\n        FROM\n            VendasProdutoPeriodo;\n    END TRY\n    BEGIN CATCH\n        -- Em caso de erro, retorna mensagem amigável\n        SET @ErroMensagem = 'Erro ao gerar relatório: ' + ERROR_MESSAGE();\n    END CATCH\nEND\nGO\n```\n\n### **Boas Práticas Aplicadas**\n- Comentários de bloco e linha.\n- Modularização com CTE.\n- Parâmetro de saída para erro.\n- Uso de `WITH (NOLOCK)` em joins somente para leitura.\n- Nomes claros para objetos e parâmetros.\n- Proteção contra SQL Injection (parâmetros fortemente tipados).\n\n---\n\n## **Parte 3: Interpretação de Plano de Execução**\n\n### **Como analisar**\n1. **Execute a view e a procedure** com `SET STATISTICS IO ON` e ative o plano de execução no SSMS.\n2. **Observe:**\n   - Se aparecem Table/Index Scans quando deveria ser Index Seek (pode faltar índice).\n   - Se há operadores caros como Hash Match ou Sort.\n   - Se o número de leituras lógicas está alto.\n3. **Exemplo de gargalos comuns:**\n   - **Falta de índices**: se o filtro de data ou status não está usando índice, pode gerar Table Scan.\n   - **Joins ineficientes**: junções em colunas não indexadas, ou em tabelas grandes, resultando em Hash Joins caros.\n\n### **Dica**\n- Para melhorar: crie índices nas colunas mais filtradas (ex: `Pedidos.Status`, `Pedidos.DataPedido`, `ItensPedido.ProdutoId`).\n- Cuidado com uso excessivo de `NOLOCK` (pode gerar leituras sujas).\n\n---\n\n## **Parte 4: Pratique Joins e Subconsultas**\n\n### **1. Clientes que nunca fizeram pedidos (`NOT EXISTS`):**\n```sql\nSELECT c.ClienteId, c.Nome, c.Email\nFROM dbo.Clientes c\nWHERE NOT EXISTS (\n    SELECT 1\n    FROM dbo.Pedidos p\n    WHERE p.ClienteId = c.ClienteId\n);\n```\n\n### **2. Produtos que nunca foram vendidos (`LEFT JOIN`):**\n```sql\nSELECT pr.ProdutoId, pr.Nome, pr.Preco\nFROM dbo.Produtos pr\nLEFT JOIN dbo.ItensPedido ip ON pr.ProdutoId = ip.ProdutoId\nWHERE ip.ItemPedidoId IS NULL;\n```\n\n### **3. Clientes com mais de 1 pedido nos últimos 30 dias (`EXISTS`):**\n```sql\nSELECT c.ClienteId, c.Nome, c.Email\nFROM dbo.Clientes c\nWHERE EXISTS (\n    SELECT 1\n    FROM dbo.Pedidos p\n    WHERE p.ClienteId = c.ClienteId\n      AND p.DataPedido >= DATEADD(DAY, -30, GETDATE())\n    GROUP BY p.ClienteId\n    HAVING COUNT(*) > 1\n);\n```\n\n---\n\n## **Dicas de Carreira e Boas Práticas**\n\n- **Versionamento:** Use scripts SQL versionados com controle de mudanças (ex: Git).\n- **Naming Convention:** Use prefixos padrão (sp_, vw_, idx_), nomes claros e consistentes.\n- **Índices:** Crie índices nas colunas de junção e filtro frequentes (ex: `Pedidos.ClienteId`, `Pedidos.Status`, `ItensPedido.ProdutoId`).\n- **Documentação:** Sempre comente suas views e procedures.\n- **Evolução:** Estude sempre! Leia planos de execução, crie ambientes de testes, aprenda sobre indexação e análise de queries.\n\n---\n\n## **Resumo**\n\nVocê viu como criar:\n- Views performáticas com CTEs e filtragem eficiente;\n- Stored procedures robustas, seguras e bem documentadas;\n- Consultas eficientes com EXISTS, LEFT JOIN e NOT EXISTS;\n- Como analisar o plano de execução e evitar armadilhas de performance.\n\nSe tiver dúvidas ou quiser avançar para temas como índices avançados e particionamento, só perguntar!"
  }
]